import{_ as e,c as t,o as a,a4 as n}from"./chunks/framework.Bl20_RFa.js";const m=JSON.parse('{"title":"Git Change Detection Integration","description":"Learn how you can use change detection in Terramate CLI to detect changed stacks.","frontmatter":{"title":"Git Change Detection Integration","description":"Learn how you can use change detection in Terramate CLI to detect changed stacks."},"headers":[],"relativePath":"cli/change-detection/integrations/git.md","filePath":"cli/change-detection/integrations/git.md"}'),i={name:"cli/change-detection/integrations/git.md"},o=n(`<h1 id="git-change-detection-integration" tabindex="-1">Git Change Detection Integration <a class="header-anchor" href="#git-change-detection-integration" aria-label="Permalink to &quot;Git Change Detection Integration&quot;">​</a></h1><p>The git change detection integration helps to detect and mark stacks as changed.</p><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><p>The approach is as simple as computing the changed stacks from the changed files discovered by the <code>git diff</code> between the revision of the last change (ie. the released revision) and the current change.</p><p>For the sake of clarity, we&#39;ll refer to the released revision as <code>baseref</code>, which is an abbreviation for <code>base reference</code>. Usually, this term corresponds to the default branch (<code>origin/main</code> or <code>origin/default</code>).</p><p>By default, the <code>baseref</code> can have two values, depending on if you&#39;re in the default branch or a feature branch, and they are:</p><ul><li><code>origin/main</code>: if you&#39;re in a feature branch.</li><li><code>HEAD^</code>: if you&#39;re in the default branch.</li></ul><p>The <a href="https://git-scm.com/docs/gitrevisions" target="_blank" rel="noreferrer">HEAD^</a> syntax means the first parent of the <code>HEAD</code> commit and the reasoning for using it for the default branch is that once you merge, your PR you need to apply the changes in the CI or locally. If the project adopts a <a href="https://git-scm.com/docs/git-merge#_fast_forward_merge" target="_blank" rel="noreferrer">non-fast-forward</a> merge strategy, every commit—aside from the first one—on the default branch becomes a merge commit. Utilizing <code>HEAD^</code> as the <code>baseref</code> enables detection of modifications in the most recently merged code Having explained that, hopefully, it becomes clear that change detection in Terramate works best if the project follows a git flow defined below (by the way, this is probably the most common git flow used by the git community):</p><ol><li>The default branch (commonly <code>main</code>) is considered to be the stable branch that represents the deployed state of your IaC.</li><li>Changes that should be planned and applied should be added through a feature or bugfix branch.</li><li>The IaC project uses <a href="https://git-scm.com/docs/git-merge#_fast_forward_merge" target="_blank" rel="noreferrer">non fast-forwarded</a> merge commits. (the default in GitHub and Bitbucket).</li></ol><p>These are standard in most companies but option 3 is controversial as it means flows depending on git <code>rebase</code> in the <code>main</code> branch would not work. If that&#39;s the case for your company, it will require a bit of manual work to apply the changes after merging but alternatively, commands such as <code>terraform apply</code> can be run in the PR&#39;s branch just before merging using the default branch base ref (<code>origin/main</code>).</p><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h2><p>The <code>baseref</code> can be manually changed by the terramate command line at any given point in time using the <code>--git-change-base</code> option or through the <a href="./../../projects/configuration">project configuration</a>, so different strategies for computing the changes are supported.</p><p>If you adopt the rebase merge strategy and need to apply modifications to stacks affected by the last rebase, it&#39;s crucial to first identify the base commit (the commit before the merge). You can then provide this commit hash in the <code>--git-change-base</code> flag to accomplish the required changes.</p><div class="language-console vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ git branch</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">main</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ git rev-parse HEAD</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80e581a8ce8cc1394da48402cc68a1f47b3cc646</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ git pull origin main</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ terramate run --changed --git-change-base 80e581a8ce8cc1394da48402cc68a1f47b3cc646 \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    -- terraform plan</span></span></code></pre></div><p><code>--git-change-base</code> supports all <a href="https://git-scm.com/docs/gitrevisions" target="_blank" rel="noreferrer">git revision</a> syntaxes, so if you know the number of parent commits you can use <code>HEAD^n</code> or <code>HEAD@{&lt;query&gt;}</code>, etc.</p>`,15),s=[o];function r(c,h,d,l,g,p){return a(),t("div",null,s)}const u=e(i,[["render",r]]);export{m as __pageData,u as default};
